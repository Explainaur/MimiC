#include <vector>
#include <unordered_map>
#include <optional>
#include <unordered_set>
#include <queue>
#include <algorithm>
#include <list>
#include <cstdint>
#include <cassert>

#include "opt/pass.h"
#include "opt/passman.h"
#include "opt/helper/cast.h"
#include "opt/helper/blkiter.h"
#include "mid/module.h"
#include "utils/hashing.h"

using namespace mimic::mid;
using namespace mimic::opt;
using namespace mimic::define;

namespace {

// expression for value numbering
class Expression {
 public:
  enum class OpCode {
    None,
    PtrAccess, ElemAccess, Cast, Phi, PhiOpr,
    // binary operations
    Add, Sub, Mul, UDiv, SDiv, URem, SRem, Equal, NotEq,
    ULess, SLess, ULessEq, SLessEq, UGreat, SGreat, UGreatEq, SGreatEq,
    And, Or, Xor, Shl, LShr, AShr,
    // unary operations
    Neg, LogicNot, Not,
  };

  Expression() : opcode_(OpCode::None) {}
  Expression(OpCode opcode, const TypePtr &type)
      : opcode_(opcode), type_(type), is_commutative_(false) {}

  bool operator==(const Expression &rhs) const {
    if (opcode_ != rhs.opcode_) return false;
    if (opcode_ == OpCode::None) return true;
    if (!type_->IsIdentical(rhs.type_)) return false;
    if (oprs_ != rhs.oprs_) return false;
    return true;
  }

  std::size_t GetHash() const {
    using namespace mimic::utils;
    return HashCombine(opcode_, type_->GetTypeId(),
                       HashCombineRange(oprs_.begin(), oprs_.end()));
  }

  // setters
  void set_opcode(OpCode opcode) { opcode_ = opcode; }
  void set_type(const TypePtr &type) { type_ = type; }
  void set_is_commutative(bool is_commutative) {
    is_commutative_ = is_commutative;
  }

  // getters
  OpCode opcode() const { return opcode_; }
  std::vector<std::uint32_t> &oprs() { return oprs_; }
  const TypePtr &type() const { return type_; }
  bool is_commutative() const { return is_commutative_; }

 private:
  // opcode of expression
  OpCode opcode_;
  // number of operators
  std::vector<std::uint32_t> oprs_;
  // type of expression
  TypePtr type_;
  // indicate whether operation is commutative, e.g. x + y <=> y + x
  bool is_commutative_;
};

// hasher for expression
struct ExprHasher {
  std::size_t operator()(const Expression &expr) const {
    return expr.GetHash();
  }
};

// hold the mapping between values and numbers
// reference: LLVM
class ValueTable : HelperPass {
 public:
  ValueTable() { Reset(); }

  void Reset() {
    values_.clear();
    exprs_.clear();
    ints_.clear();
    next_number_ = 1;
  }

  std::uint32_t LookupOrAdd(Value *val);
  std::uint32_t Lookup(Value *val, bool verify);
  void Add(Value *val, std::uint32_t num);

  void RunOn(AccessSSA &ssa) override;
  void RunOn(CastSSA &ssa) override;
  void RunOn(PhiSSA &ssa) override;
  void RunOn(PhiOperandSSA &ssa) override;
  void RunOn(BinarySSA &ssa) override;
  void RunOn(UnarySSA &ssa) override;
  void RunOn(ConstIntSSA &ssa) override;
  void RunOn(ConstZeroSSA &ssa) override;

 private:
  static Expression::OpCode GetSwappedPredicate(BinarySSA::Operator op);
  Expression CreateExpr(User *user, Expression::OpCode opcode);
  std::uint32_t LookupOrAdd(const Expression &expr);
  std::uint32_t LookupOrAdd(std::uint32_t const_int);

  // value numbers of all values
  std::unordered_map<Value *, std::uint32_t> values_;
  // value numbers of all expressions
  std::unordered_map<Expression, std::uint32_t, ExprHasher> exprs_;
  // value numbers of all constant integers
  std::unordered_map<std::uint32_t, std::uint32_t> ints_;
  // next value number
  // valid value numbers starts with 1
  std::uint32_t next_number_;
  // number generated by visitor methods (of expressions or constants)
  std::optional<std::uint32_t> gen_num_;
};


/*
  perform global value numbering
  a naive implementation, similar to mem2reg
*/
class GlobalValueNumberingPass : public FunctionPass {
 public:
  GlobalValueNumberingPass() {}

  bool RunOnFunction(const FuncPtr &func) override {
    if (func->is_decl()) return false;
    changed_ = false;
    // traverse all blocks in RPO
    auto entry = SSACast<BlockSSA>(func->entry().get());
    for (const auto &i : RPOTraverse(entry)) {
      i->RunPass(*this);
    }
    // process created phi nodes
    ProcessPhi();
    return changed_;
  }

  void CleanUp() override {
    values_.Reset();
    val_defs_.clear();
    ptr_defs_.clear();
    global_vals_.clear();
    tracked_ptrs_.clear();
    assert(created_phis_.empty());
  }

  void RunOn(BlockSSA &ssa) override {
    // traverse all instructions
    auto &insts = ssa.insts();
    for (auto it = insts.begin(); it != insts.end();) {
      bool remove_flag = false;
      if (auto load = SSADynCast<LoadSSA>(it->get())) {
        remove_flag = ProcessLoad(&ssa, load);
      }
      else if (auto store = SSADynCast<StoreSSA>(it->get())) {
        remove_flag = ProcessStore(&ssa, store);
      }
      else {
        remove_flag = ProcessValue(&ssa, *it);
      }
      // check if need to remove
      if (remove_flag) {
        if (!changed_) changed_ = true;
        it = insts.erase(it);
      }
      else {
        ++it;
      }
    }
  }

 private:
  using LocalDefs =
      std::unordered_map<BlockSSA *,
                         std::unordered_map<std::uint32_t, SSAPtr>>;

  struct InstInfo {
    Value *val;
    BlockSSA *parent;
  };

  struct PhiInfo {
    // phi node
    SSAPtr phi;
    // block where phi node located
    BlockSSA *block;
    // instruction that caused this phi node
    InstInfo inst;
  };

  bool ProcessLoad(BlockSSA *block, LoadSSA *load);
  bool ProcessStore(BlockSSA *block, StoreSSA *store);
  bool ProcessValue(BlockSSA *block, const SSAPtr &value);
  void ProcessPhi();

  void WriteValue(LocalDefs &defs, BlockSSA *block, std::uint32_t num,
                  const SSAPtr &val);
  SSAPtr ReadValue(LocalDefs &defs, BlockSSA *block, std::uint32_t num,
                   InstInfo inst);
  SSAPtr ReadValueRecursive(LocalDefs &defs, BlockSSA *block,
                            std::uint32_t num, InstInfo inst);
  bool ReplaceWith(Value *val, const SSAPtr &repl);
  void AddPhiOperands(const SSAPtr &phi, BlockSSA *block, InstInfo inst);
  bool IsTrivialPhi(PhiSSA *phi);

  bool changed_;
  // value table
  ValueTable values_;
  // local definitions for values & load/store instructions
  LocalDefs val_defs_, ptr_defs_;
  // number of handled values
  std::unordered_set<std::uint32_t> global_vals_;
  // value number of tracked pointers
  // only pointers of local variables will be tracked
  std::unordered_set<std::uint32_t> tracked_ptrs_;
  // all created phi nodes
  std::queue<PhiInfo> created_phis_;
};

}  // namespace

// register current pass
REGISTER_PASS(GlobalValueNumberingPass, gvn)
    .set_min_opt_level(2)
    .set_stages(PassStage::Opt)
    .Requires("adce")
    .Requires("inliner")
    .Requires("naive_unroll")
    .Invalidates("loop_info");


/*
==================== methonds of 'ValueTabel' ====================
*/
// returns the predicate as if the operands were swapped
Expression::OpCode ValueTable::GetSwappedPredicate(
    BinarySSA::Operator op) {
  using Op = BinarySSA::Operator;
  using OpCode = Expression::OpCode;
  switch (op) {
    case Op::ULess: return OpCode::UGreatEq;
    case Op::SLess: return OpCode::SGreatEq;
    case Op::ULessEq: return OpCode::UGreat;
    case Op::SLessEq: return OpCode::SGreat;
    case Op::UGreat: return OpCode::ULessEq;
    case Op::SGreat: return OpCode::SLessEq;
    case Op::UGreatEq: return OpCode::ULess;
    case Op::SGreatEq: return OpCode::SLess;
    default: assert(false); return OpCode::None;
  }
}

// create an expression representation from the specific user
Expression ValueTable::CreateExpr(User *user, Expression::OpCode opcode) {
  Expression expr(opcode, user->type());
  for (const auto &i : *user) {
    expr.oprs().push_back(LookupOrAdd(i.value().get()));
  }
  return expr;
}

std::uint32_t ValueTable::LookupOrAdd(const Expression &expr) {
  auto it = exprs_.find(expr);
  if (it != exprs_.end()) return it->second;
  // new expression, add to map
  exprs_.insert({expr, next_number_});
  return next_number_++;
}

std::uint32_t ValueTable::LookupOrAdd(std::uint32_t const_int) {
  auto it = ints_.find(const_int);
  if (it != ints_.end()) return it->second;
  // new constant integer, add to map
  ints_.insert({const_int, next_number_});
  return next_number_++;
}

// lookup the value number of the specific value
// add new number to table if the value does not exist
std::uint32_t ValueTable::LookupOrAdd(Value *val) {
  auto it = values_.find(val);
  if (it != values_.end()) return it->second;
  // handle by type of value
  gen_num_ = {};
  val->RunPass(*this);
  // add to map
  if (gen_num_) {
    values_[val] = *gen_num_;
    return *gen_num_;
  }
  else {
    // new value, add to map & update next number
    values_[val] = next_number_;
    return next_number_++;
  }
}

// lookup the value number of the specific value
// returns zero if the value does not exist
std::uint32_t ValueTable::Lookup(Value *val, bool verify) {
  auto it = values_.find(val);
  if (verify) {
    assert(it != values_.end());
    return it->second;
  }
  return it != values_.end() ? it->second : 0;
}

// assign the specific value number to value
void ValueTable::Add(Value *val, std::uint32_t num) {
  assert(num);
  values_.insert({val, num});
}

void ValueTable::RunOn(AccessSSA &ssa) {
  using AccTy = AccessSSA::AccessType;
  using OpCode = Expression::OpCode;
  auto op = ssa.acc_type() == AccTy::Pointer ? OpCode::PtrAccess
                                             : OpCode::ElemAccess;
  auto expr = CreateExpr(&ssa, op);
  gen_num_ = LookupOrAdd(expr);
}

void ValueTable::RunOn(CastSSA &ssa) {
  auto expr = CreateExpr(&ssa, Expression::OpCode::Cast);
  gen_num_ = LookupOrAdd(expr);
}

void ValueTable::RunOn(PhiSSA &ssa) {
  auto expr = CreateExpr(&ssa, Expression::OpCode::Phi);
  // phi node is commutative, sort the operand list
  expr.set_is_commutative(true);
  std::sort(expr.oprs().begin(), expr.oprs().end());
  gen_num_ = LookupOrAdd(expr);
}

void ValueTable::RunOn(PhiOperandSSA &ssa) {
  Expression expr(Expression::OpCode::PhiOpr, ssa.type());
  // add value of current operand
  if (!Lookup(ssa.value().get(), false)) {
    // ignore back edges
    Add(ssa.value().get(), next_number_);
    expr.oprs().push_back(next_number_++);
  }
  else {
    expr.oprs().push_back(LookupOrAdd(ssa.value().get()));
  }
  // add block of current operand
  expr.oprs().push_back(LookupOrAdd(ssa.block().get()));
  gen_num_ = LookupOrAdd(expr);
}

void ValueTable::RunOn(BinarySSA &ssa) {
  using Op = BinarySSA::Operator;
  using OpCode = Expression::OpCode;
  // create expression
  Expression expr;
  expr.set_type(ssa.type());
  switch (ssa.op()) {
    case Op::Add: expr.set_opcode(OpCode::Add); break;
    case Op::Sub: expr.set_opcode(OpCode::Sub); break;
    case Op::Mul: expr.set_opcode(OpCode::Mul); break;
    case Op::UDiv: expr.set_opcode(OpCode::UDiv); break;
    case Op::SDiv: expr.set_opcode(OpCode::SDiv); break;
    case Op::URem: expr.set_opcode(OpCode::URem); break;
    case Op::SRem: expr.set_opcode(OpCode::SRem); break;
    case Op::Equal: expr.set_opcode(OpCode::Equal); break;
    case Op::NotEq: expr.set_opcode(OpCode::NotEq); break;
    case Op::ULess: expr.set_opcode(OpCode::ULess); break;
    case Op::SLess: expr.set_opcode(OpCode::SLess); break;
    case Op::ULessEq: expr.set_opcode(OpCode::ULessEq); break;
    case Op::SLessEq: expr.set_opcode(OpCode::SLessEq); break;
    case Op::UGreat: expr.set_opcode(OpCode::UGreat); break;
    case Op::SGreat: expr.set_opcode(OpCode::SGreat); break;
    case Op::UGreatEq: expr.set_opcode(OpCode::UGreatEq); break;
    case Op::SGreatEq: expr.set_opcode(OpCode::SGreatEq); break;
    case Op::And: expr.set_opcode(OpCode::And); break;
    case Op::Or: expr.set_opcode(OpCode::Or); break;
    case Op::Xor: expr.set_opcode(OpCode::Xor); break;
    case Op::Shl: expr.set_opcode(OpCode::Shl); break;
    case Op::LShr: expr.set_opcode(OpCode::LShr); break;
    case Op::AShr: expr.set_opcode(OpCode::AShr); break;
    default: assert(false);
  }
  // add operands
  expr.oprs().push_back(LookupOrAdd(ssa.lhs().get()));
  expr.oprs().push_back(LookupOrAdd(ssa.rhs().get()));
  // check if is commutative
  switch (ssa.op()) {
    case Op::Add: case Op::Mul: case Op::Equal: case Op::NotEq:
    case Op::And: case Op::Or: case Op::Xor: {
      expr.set_is_commutative(true);
      if (expr.oprs()[0] > expr.oprs()[1]) {
        std::swap(expr.oprs()[0], expr.oprs()[1]);
      }
      break;
    }
    case Op::ULess: case Op::SLess: case Op::ULessEq: case Op::SLessEq:
    case Op::UGreat: case Op::SGreat: case Op::UGreatEq:
    case Op::SGreatEq: {
      expr.set_is_commutative(true);
      if (expr.oprs()[0] > expr.oprs()[1]) {
        std::swap(expr.oprs()[0], expr.oprs()[1]);
        expr.set_opcode(GetSwappedPredicate(ssa.op()));
      }
    }
    default:;
  }
  // get number of current expression
  gen_num_ = LookupOrAdd(expr);
}

void ValueTable::RunOn(UnarySSA &ssa) {
  using Op = UnarySSA::Operator;
  using OpCode = Expression::OpCode;
  // create expression
  Expression expr;
  expr.set_type(ssa.type());
  switch (ssa.op()) {
    case Op::Neg: expr.set_opcode(OpCode::Neg); break;
    case Op::LogicNot: expr.set_opcode(OpCode::LogicNot); break;
    case Op::Not: expr.set_opcode(OpCode::Not); break;
    default: assert(false);
  }
  // add operands
  expr.oprs().push_back(LookupOrAdd(ssa.opr().get()));
  // get number of current expression
  gen_num_ = LookupOrAdd(expr);
}

void ValueTable::RunOn(ConstIntSSA &ssa) {
  gen_num_ = LookupOrAdd(ssa.value());
}

void ValueTable::RunOn(ConstZeroSSA &ssa) {
  // handle integers/pointers only
  if (ssa.type()->IsInteger() || ssa.type()->IsPointer()) {
    gen_num_ = LookupOrAdd(static_cast<std::uint32_t>(0));
  }
}


/*
==================== methods of GlobalValueNumbering ====================
*/
// handle with load instructions
// returns true if current value has already been replaced
bool GlobalValueNumberingPass::ProcessLoad(BlockSSA *block,
                                           LoadSSA *load) {
  auto ptr_num = values_.LookupOrAdd(load->ptr().get());
  // skip untracked pointers
  if (!tracked_ptrs_.count(ptr_num)) return false;
  // update local definitions
  auto val = ReadValue(ptr_defs_, block, ptr_num, {load, block});
  return ReplaceWith(load, val);
}

// handle with store instructions
// returns true if current value has already been replaced
bool GlobalValueNumberingPass::ProcessStore(BlockSSA *block,
                                            StoreSSA *store) {
  auto ptr_num = values_.LookupOrAdd(store->ptr().get());
  // skip untracked pointers
  if (!tracked_ptrs_.count(ptr_num)) return false;
  // update local definition of pointer
  WriteValue(ptr_defs_, block, ptr_num, store->value());
  return false;
}

// handle with other instructions
// returns true if current value has already been replaced
bool GlobalValueNumberingPass::ProcessValue(BlockSSA *block,
                                            const SSAPtr &value) {
  // skip 'value' if it does not yield a value
  if (!value->type()) return false;
  auto num = values_.LookupOrAdd(value.get());
  // check if pointer can be tracked
  if (value->type()->IsPointer()) {
    if (IsSSA<AllocaSSA>(value)) {
      // track alloca instructions only
      tracked_ptrs_.insert(num);
    }
    else if (auto acc = SSADynCast<AccessSSA>(value.get())) {
      // track access if it's base pointer is tracked
      // and index is not a phi node
      auto ptr_num = values_.LookupOrAdd(acc->ptr().get());
      if (tracked_ptrs_.count(ptr_num) && !IsSSA<PhiSSA>(acc->index())) {
        tracked_ptrs_.insert(num);
      }
    }
    else if (auto cast = SSADynCast<CastSSA>(value.get())) {
      // track pointer cast if it's operand is tracked
      auto ptr_num = values_.LookupOrAdd(cast->opr().get());
      if (tracked_ptrs_.count(ptr_num)) tracked_ptrs_.insert(num);
    }
  }
  // update local definitions
  if (global_vals_.insert(num).second) {
    WriteValue(val_defs_, block, num, value);
    return false;
  }
  else {
    auto val = ReadValue(val_defs_, block, num, {value.get(), block});
    return ReplaceWith(value.get(), val);
  }
}

// handle with created phi nodes
void GlobalValueNumberingPass::ProcessPhi() {
  std::list<PhiInfo> phis;
  // try to add operands for all created phi nodes
  while (!created_phis_.empty()) {
    const auto &[phi, block, load] = created_phis_.front();
    AddPhiOperands(phi, block, load);
    phis.push_back(created_phis_.front());
    created_phis_.pop();
  }
  // check if there are trivial phi nodes
  bool changed = true;
  while (changed) {
    changed = false;
    for (auto it = phis.begin(); it != phis.end();) {
      auto phi = SSACast<PhiSSA>(it->phi.get());
      if (IsTrivialPhi(phi)) {
        changed = true;
        it = phis.erase(it);
      }
      else {
        ++it;
      }
    }
  }
  // place all remaining phi nodes into the block where they are
  for (const auto &pi : phis) {
    pi.inst.val->ReplaceBy(pi.phi);
    pi.inst.parent->insts().remove_if(
        [&pi](const SSAPtr &i) { return i.get() == pi.inst.val; });
    pi.block->insts().push_front(pi.phi);
    if (!changed_) changed_ = true;
  }
}

void GlobalValueNumberingPass::WriteValue(LocalDefs &defs, BlockSSA *block,
                                          std::uint32_t num,
                                          const SSAPtr &val) {
  defs[block][num] = val;
}

SSAPtr GlobalValueNumberingPass::ReadValue(LocalDefs &defs, BlockSSA *block,
                                           std::uint32_t num,
                                           InstInfo inst) {
  const auto &d = defs[block];
  auto it = d.find(num);
  if (it != d.end()) {
    return it->second;
  }
  else {
    return ReadValueRecursive(defs, block, num, inst);
  }
}

SSAPtr GlobalValueNumberingPass::ReadValueRecursive(LocalDefs &defs,
                                                    BlockSSA *block,
                                                    std::uint32_t num,
                                                    InstInfo inst) {
  SSAPtr val;
  if (block->size() == 1) {
    // block only has one predecessor, no phi needed
    auto pred = SSACast<BlockSSA>((*block)[0].value().get());
    val = ReadValue(defs, pred, num, inst);
  }
  else {
    // create an empty phi node
    auto phi = std::make_shared<PhiSSA>(SSAPtrList());
    phi->set_type(inst.val->type());
    phi->set_logger(inst.val->logger());
    // remember it
    created_phis_.push({phi, block, inst});
    val = phi;
  }
  // update local definition
  WriteValue(defs, block, num, val);
  return val;
}

bool GlobalValueNumberingPass::ReplaceWith(Value *val,
                                           const SSAPtr &repl) {
  if (!IsSSA<PhiSSA>(repl)) {
    val->ReplaceBy(repl);
    return true;
  }
  else {
    return false;
  }
}

void GlobalValueNumberingPass::AddPhiOperands(const SSAPtr &phi,
                                              BlockSSA *block,
                                              InstInfo inst) {
  auto phi_ptr = SSACast<PhiSSA>(phi.get());
  phi_ptr->Reserve(block->size());
  // determine operands from predecessors
  for (const auto &i : *block) {
    // get number of value
    std::uint32_t num;
    LocalDefs *defs;
    if (auto load = SSADynCast<LoadSSA>(inst.val)) {
      num = values_.Lookup(load->ptr().get(), true);
      defs = &ptr_defs_;
    }
    else {
      num = values_.Lookup(inst.val, true);
      defs = &val_defs_;
    }
    // read value
    auto pred = SSACast<BlockSSA>(i.value());
    auto val = ReadValue(*defs, pred.get(), num, inst);
    assert(val->type()->IsIdentical(phi_ptr->type()));
    // create phi operand
    auto mod = MakeModule(phi_ptr->logger());
    phi_ptr->AddValue(mod.CreatePhiOperand(val, pred));
  }
}

bool GlobalValueNumberingPass::IsTrivialPhi(PhiSSA *phi) {
  SSAPtr same;
  // scan all operands
  for (const auto &i : *phi) {
    auto op_ptr = SSACast<PhiOperandSSA>(i.value().get());
    const auto &op = op_ptr->value();
    // unique value, undefined value or self-reference
    if (op == same || op->IsUndef() || op.get() == phi) continue;
    // the phi node merges at least two values, not trivial
    if (same) return false;
    // remember current operand
    same = op;
  }
  // unreachable or in the start block
  if (!same) same = MakeModule(phi->logger()).GetUndef(phi->type());
  // reroute all uses of phi node to 'same'
  phi->ReplaceBy(same);
  return true;
}
